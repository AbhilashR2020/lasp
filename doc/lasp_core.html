<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>Module lasp_core</title>
<link rel="stylesheet" type="text/css" href="stylesheet.css" title="EDoc">
</head>
<body bgcolor="white">
<div class="navbar"><a name="#navbar_top"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<hr>

<h1>Module lasp_core</h1>
<ul class="index"><li><a href="#types">Data Types</a></li><li><a href="#index">Function Index</a></li><li><a href="#functions">Function Details</a></li></ul>


<h2><a name="types">Data Types</a></h2>

<h3 class="typedecl"><a name="type-actor">actor()</a></h3>
<p><tt>actor() = term()</tt></p>


<h3 class="typedecl"><a name="type-args">args()</a></h3>
<p><tt>args() = list()</tt></p>


<h3 class="typedecl"><a name="type-func">func()</a></h3>
<p><tt>func() = atom()</tt></p>


<h3 class="typedecl"><a name="type-id">id()</a></h3>
<p><tt>id() = binary()</tt></p>


<h3 class="typedecl"><a name="type-metadata">metadata()</a></h3>
<p><tt>metadata() = <a href="orddict.html#type-orddict">orddict:orddict()</a></tt></p>


<h3 class="typedecl"><a name="type-module">module()</a></h3>
<p><tt>module() = atom()</tt></p>


<h3 class="typedecl"><a name="type-operation">operation()</a></h3>
<p><tt>operation() = {atom(), <a href="#type-value">value()</a>} | {atom(), <a href="#type-value">value()</a>, <a href="#type-value">value()</a>}</tt></p>


<h3 class="typedecl"><a name="type-pending_threshold">pending_threshold()</a></h3>
<p><tt>pending_threshold() = {threshold, read | wait, pid(), <a href="#type-type">type()</a>, <a href="#type-threshold">threshold()</a>}</tt></p>


<h3 class="typedecl"><a name="type-store">store()</a></h3>
<p><tt>store() = <a href="ets.html#type-tid">ets:tid()</a> | <a href="eleveldb.html#type-db_ref">eleveldb:db_ref()</a> | atom() | reference() | pid()</tt></p>


<h3 class="typedecl"><a name="type-threshold">threshold()</a></h3>
<p><tt>threshold() = <a href="#type-value">value()</a> | {strict, <a href="#type-value">value()</a>}</tt></p>


<h3 class="typedecl"><a name="type-type">type()</a></h3>
<p><tt>type() = lasp_ivar | lasp_orset | lasp_orset_gbtree</tt></p>


<h3 class="typedecl"><a name="type-value">value()</a></h3>
<p><tt>value() = term()</tt></p>


<h3 class="typedecl"><a name="type-var">var()</a></h3>
<p><tt>var() = {<a href="#type-id">id()</a>, <a href="#type-type">type()</a>, <a href="#type-metadata">metadata()</a>, <a href="#type-value">value()</a>}</tt></p>


<h2><a name="index">Function Index</a></h2>
<table width="100%" border="1" cellspacing="0" cellpadding="2" summary="function index"><tr><td valign="top"><a href="#bind-3">bind/3</a></td><td>Define a dataflow variable to be bound a value.</td></tr>
<tr><td valign="top"><a href="#bind-4">bind/4</a></td><td>Define a dataflow variable to be bound a value.</td></tr>
<tr><td valign="top"><a href="#bind_to-3">bind_to/3</a></td><td>Define a dataflow variable to be bound to another dataflow
       variable.</td></tr>
<tr><td valign="top"><a href="#bind_to-4">bind_to/4</a></td><td>Define a dataflow variable to be bound to another dataflow       
variable.</td></tr>
<tr><td valign="top"><a href="#bind_to-5">bind_to/5</a></td><td></td></tr>
<tr><td valign="top"><a href="#declare-1">declare/1</a></td><td>Declare a dataflow variable in a provided by identifer.</td></tr>
<tr><td valign="top"><a href="#declare-2">declare/2</a></td><td>Declare a dataflow variable, as a given type.</td></tr>
<tr><td valign="top"><a href="#declare-3">declare/3</a></td><td>Declare a dataflow variable in a provided by identifer.</td></tr>
<tr><td valign="top"><a href="#declare-4">declare/4</a></td><td>Declare a dataflow variable in a provided by identifer.</td></tr>
<tr><td valign="top"><a href="#filter-4">filter/4</a></td><td>Filter values from one lattice into another.</td></tr>
<tr><td valign="top"><a href="#filter-6">filter/6</a></td><td>Filter values from one lattice into another.</td></tr>
<tr><td valign="top"><a href="#fold-4">fold/4</a></td><td>Fold values from one lattice into another.</td></tr>
<tr><td valign="top"><a href="#fold-6">fold/6</a></td><td>Fold values from one lattice into another.</td></tr>
<tr><td valign="top"><a href="#intersection-4">intersection/4</a></td><td>Compute the intersection of two sets.</td></tr>
<tr><td valign="top"><a href="#intersection-7">intersection/7</a></td><td>Compute the intersection of two sets.</td></tr>
<tr><td valign="top"><a href="#map-4">map/4</a></td><td>Map values from one lattice into another.</td></tr>
<tr><td valign="top"><a href="#map-6">map/6</a></td><td>Lap values from one lattice into another.</td></tr>
<tr><td valign="top"><a href="#product-4">product/4</a></td><td>Compute the cartesian product of two sets.</td></tr>
<tr><td valign="top"><a href="#product-7">product/7</a></td><td>Compute the cartesian product of two sets.</td></tr>
<tr><td valign="top"><a href="#read-2">read/2</a></td><td>Perform a read for a particular identifier.</td></tr>
<tr><td valign="top"><a href="#read-3">read/3</a></td><td>Perform a monotonic read read for a particular identifier.</td></tr>
<tr><td valign="top"><a href="#read-6">read/6</a></td><td>Perform a read (or monotonic read) for a particular identifier.</td></tr>
<tr><td valign="top"><a href="#read_any-2">read_any/2</a></td><td>Perform a monotonic read for a series of given idenfitiers --
       first response wins.</td></tr>
<tr><td valign="top"><a href="#reply_to_all-2">reply_to_all/2</a></td><td>Given a group of processes which are blocking on reads, notify
       them of bound values or met thresholds.</td></tr>
<tr><td valign="top"><a href="#reply_to_all-3">reply_to_all/3</a></td><td>Given a group of processes which are blocking on reads, notify
       them of bound values or met thresholds.</td></tr>
<tr><td valign="top"><a href="#start-1">start/1</a></td><td>Initialize the storage backend.</td></tr>
<tr><td valign="top"><a href="#thread-4">thread/4</a></td><td>Spawn a function.</td></tr>
<tr><td valign="top"><a href="#union-4">union/4</a></td><td>Compute the union of two sets.</td></tr>
<tr><td valign="top"><a href="#union-7">union/7</a></td><td>Compute the union of two sets.</td></tr>
<tr><td valign="top"><a href="#update-4">update/4</a></td><td>Update a dataflow variable given an operation.</td></tr>
<tr><td valign="top"><a href="#update-5">update/5</a></td><td></td></tr>
<tr><td valign="top"><a href="#wait_needed-2">wait_needed/2</a></td><td>Pause execution until value requested with given threshold.</td></tr>
<tr><td valign="top"><a href="#wait_needed-3">wait_needed/3</a></td><td>Pause execution until value requested with given threshold.</td></tr>
<tr><td valign="top"><a href="#wait_needed-6">wait_needed/6</a></td><td>Callback wait_needed function for lasp_vnode, where we       
change the reply and blocking replies.</td></tr>
<tr><td valign="top"><a href="#write-4">write/4</a></td><td>Send responses to waiting threads, via messages.</td></tr>
</table>

<h2><a name="functions">Function Details</a></h2>

<h3 class="function"><a name="bind-3">bind/3</a></h3>
<div class="spec">
<p><tt>bind(Id::<a href="#type-id">id()</a>, Value::<a href="#type-value">value()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div><p>Define a dataflow variable to be bound a value.</p>

<h3 class="function"><a name="bind-4">bind/4</a></h3>
<div class="spec">
<p><tt>bind(Id::<a href="#type-id">id()</a>, Value::<a href="#type-value">value()</a>, MetadataFun::function(), Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div><p>Define a dataflow variable to be bound a value.</p>

<h3 class="function"><a name="bind_to-3">bind_to/3</a></h3>
<div class="spec">
<p><tt>bind_to(Id::<a href="#type-id">id()</a>, TheirId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p>Define a dataflow variable to be bound to another dataflow
       variable.
 </p>

<h3 class="function"><a name="bind_to-4">bind_to/4</a></h3>
<div class="spec">
<p><tt>bind_to(AccId::<a href="#type-id">id()</a>, Id::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>, BindFun::function()) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Define a dataflow variable to be bound to another dataflow       
variable.</p>
 
       <p>This version, performs a partial bind to another dataflow       
variable.</p>
 
       <p><code>FetchFun</code> is used to specify how to find the target identifier,       
given it is located in another data store.</p>
 
       <code>FromPid</code> is sent a message with the target identifiers value,
       if the target identifier is already bound.
 </p>

<h3 class="function"><a name="bind_to-5">bind_to/5</a></h3>
<div class="spec">
<p><tt>bind_to(AccId, Id, Store, BindFun, ReadFun) -&gt; any()</tt></p>
</div>

<h3 class="function"><a name="declare-1">declare/1</a></h3>
<div class="spec">
<p><tt>declare(Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-id">id()</a>}</tt><br></p>
</div><p>Declare a dataflow variable in a provided by identifer.</p>

<h3 class="function"><a name="declare-2">declare/2</a></h3>
<div class="spec">
<p><tt>declare(Type::<a href="#type-type">type()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-id">id()</a>}</tt><br></p>
</div><p>Declare a dataflow variable, as a given type.</p>

<h3 class="function"><a name="declare-3">declare/3</a></h3>
<div class="spec">
<p><tt>declare(Id::<a href="#type-id">id()</a>, Type::<a href="#type-type">type()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-id">id()</a>}</tt><br></p>
</div><p>Declare a dataflow variable in a provided by identifer.</p>

<h3 class="function"><a name="declare-4">declare/4</a></h3>
<div class="spec">
<p><tt>declare(Id::<a href="#type-id">id()</a>, Type::<a href="#type-type">type()</a>, MetadataFun::function(), Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-id">id()</a>}</tt><br></p>
</div><p>Declare a dataflow variable in a provided by identifer.</p>

<h3 class="function"><a name="filter-4">filter/4</a></h3>
<div class="spec">
<p><tt>filter(Id::<a href="#type-id">id()</a>, Function::function(), AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Filter values from one lattice into another.</p>
 
       Applies the given <code>Function</code> as a filter over the items in <code>Id</code>,
       placing the result in <code>AccId</code>, both of which need to be declared
       variables.
 </p>

<h3 class="function"><a name="filter-6">filter/6</a></h3>
<div class="spec">
<p><tt>filter(Id::<a href="#type-id">id()</a>, Function::function(), AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>, BindFun::function(), ReadFun::function()) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Filter values from one lattice into another.</p>
 
       <p>Applies the given <code>Function</code> as a filter over the items in <code>Id</code>,
       placing the result in <code>AccId</code>, both of which need to be declared       
variables.</p>
 
       Similar to <a href="#filter-4"><code>filter/4</code></a>, however, provides an override
       function for the <code>BindFun</code>, which is responsible for binding the
       result, for instance, when it's located in another table.
 </p>

<h3 class="function"><a name="fold-4">fold/4</a></h3>
<div class="spec">
<p><tt>fold(Id::<a href="#type-id">id()</a>, Function::function(), AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Fold values from one lattice into another.</p>
 
       Applies the given <code>Function</code> as a fold over the items in <code>Id</code>,
       placing the result in <code>AccId</code>, both of which need to be declared
       variables.
 </p>

<h3 class="function"><a name="fold-6">fold/6</a></h3>
<div class="spec">
<p><tt>fold(Id::<a href="#type-id">id()</a>, Function::function(), AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>, BindFun::function(), ReadFun::function()) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Fold values from one lattice into another.</p>
 
       <p>Applies the given <code>Function</code> as a fold over the items in <code>Id</code>,
       placing the result in <code>AccId</code>, both of which need to be declared       
variables.</p>
 
       Similar to <a href="#fold-4"><code>fold/4</code></a>, however, provides an override
       function for the <code>BindFun</code>, which is responsible for binding the
       result, for instance, when it's located in another table.
 </p>

<h3 class="function"><a name="intersection-4">intersection/4</a></h3>
<div class="spec">
<p><tt>intersection(Left::<a href="#type-id">id()</a>, Right::<a href="#type-id">id()</a>, Intersection::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Compute the intersection of two sets.</p>
 
       Computes the intersection of two sets and bind the result
       to a third.
 </p>

<h3 class="function"><a name="intersection-7">intersection/7</a></h3>
<div class="spec">
<p><tt>intersection(Left::<a href="#type-id">id()</a>, Right::<a href="#type-id">id()</a>, AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>, BindFun::function(), ReadLeftFun::function(), ReadRightFun::function()) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Compute the intersection of two sets.</p>
 
       <p>Computes the intersection of two sets and bind the result       
to a third.</p>
 
       Similar to <a href="#intersection-4"><code>intersection/4</code></a>, however, provides an override
       function for the <code>BindFun</code>, which is responsible for binding the
       result, for instance, when it's located in another table.
 </p>

<h3 class="function"><a name="map-4">map/4</a></h3>
<div class="spec">
<p><tt>map(Id::<a href="#type-id">id()</a>, Function::function(), AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Map values from one lattice into another.</p>
 
       Applies the given <code>Function</code> as a map over the items in <code>Id</code>,
       placing the result in <code>AccId</code>, both of which need to be declared
       variables.
 </p>

<h3 class="function"><a name="map-6">map/6</a></h3>
<div class="spec">
<p><tt>map(Id::<a href="#type-id">id()</a>, Function::function(), AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>, BindFun::function(), ReadFun::function()) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Lap values from one lattice into another.</p>
 
       <p>Applies the given <code>Function</code> as a map over the items in <code>Id</code>,
       placing the result in <code>AccId</code>, both of which need to be declared       
variables.</p>
 
       Similar to <a href="#map-4"><code>map/4</code></a>, however, provides an override
       function for the <code>BindFun</code>, which is responsible for binding the
       result, for instance, when it's located in another table.
 </p>

<h3 class="function"><a name="product-4">product/4</a></h3>
<div class="spec">
<p><tt>product(Left::<a href="#type-id">id()</a>, Right::<a href="#type-id">id()</a>, Product::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Compute the cartesian product of two sets.</p>
 
       Computes the cartestian product of two sets and bind the result
       to a third.
 </p>

<h3 class="function"><a name="product-7">product/7</a></h3>
<div class="spec">
<p><tt>product(Left::<a href="#type-id">id()</a>, Right::<a href="#type-id">id()</a>, AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>, BindFun::function(), ReadLeftFun::function(), ReadRightFun::function()) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Compute the cartesian product of two sets.</p>
 
       <p>Computes the cartestian product of two sets and bind the result       
to a third.</p>
 
       Similar to <a href="#product-4"><code>product/4</code></a>, however, provides an override
       function for the <code>BindFun</code>, which is responsible for binding the
       result, for instance, when it's located in another table.
 </p>

<h3 class="function"><a name="read-2">read/2</a></h3>
<div class="spec">
<p><tt>read(Id::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div><p><p>Perform a read for a particular identifier.</p>
 
       Given an <code>Id</code>, perform a blocking read until the variable is
       bound.
 </p>

<h3 class="function"><a name="read-3">read/3</a></h3>
<div class="spec">
<p><tt>read(Id::<a href="#type-id">id()</a>, Threshold::<a href="#type-value">value()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div><p><p>Perform a monotonic read read for a particular identifier.</p>
 
       <p>Given an <code>Id</code>, perform a blocking read until the variable is       
bound.</p>
 
       This operation blocks until <code>Threshold</code> has been reached.
 </p>

<h3 class="function"><a name="read-6">read/6</a></h3>
<div class="spec">
<p><tt>read(Id::<a href="#type-id">id()</a>, Threshold0::<a href="#type-value">value()</a>, Store::<a href="#type-store">store()</a>, Self::pid(), ReplyFun::function(), BlockingFun::function()) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div><p><p>Perform a read (or monotonic read) for a particular identifier.</p>
 
       <p>Given an <code>Id</code>, perform a blocking read until the variable is       
bound.</p>
 
       Perform a read -- reads will either block until the <code>Threshold</code>
       is met, or the variable is bound.  Reads will be performed
       against the <code>Store</code> provided.  When the process should register
       itself for notification of the variable being bound, it should
       supply the process identifier for notifications as <code>Self</code>.
       Finally, the <code>ReplyFun</code> and <code>BlockingFun</code> functions will be
       executed in the event that the reply is available immediately,
       or it will have to wait for the notification, in the event the
       variable is unbound or has not met the threshold yet.
 </p>

<h3 class="function"><a name="read_any-2">read_any/2</a></h3>
<div class="spec">
<p><tt>read_any(Reads::[{<a href="#type-id">id()</a>, <a href="#type-value">value()</a>}], Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div><p>Perform a monotonic read for a series of given idenfitiers --
       first response wins.
 </p>

<h3 class="function"><a name="reply_to_all-2">reply_to_all/2</a></h3>
<div class="spec">
<p><tt>reply_to_all(List::[pid() | <a href="#type-pending_threshold">pending_threshold()</a>], Result::term()) -&gt; {ok, [<a href="#type-pending_threshold">pending_threshold()</a>]}</tt><br></p>
</div><p>Given a group of processes which are blocking on reads, notify
       them of bound values or met thresholds.
 </p>

<h3 class="function"><a name="reply_to_all-3">reply_to_all/3</a></h3>
<div class="spec">
<p><tt>reply_to_all(T::[pid() | <a href="#type-pending_threshold">pending_threshold()</a>], StillWaiting0::[<a href="#type-pending_threshold">pending_threshold()</a>], Result::term()) -&gt; {ok, [<a href="#type-pending_threshold">pending_threshold()</a>]}</tt><br></p>
</div><p>Given a group of processes which are blocking on reads, notify
       them of bound values or met thresholds.
 </p>

<h3 class="function"><a name="start-1">start/1</a></h3>
<div class="spec">
<p><tt>start(Identifier::atom()) -&gt; {ok, <a href="#type-store">store()</a>} | {error, term()}</tt><br></p>
</div><p>Initialize the storage backend.</p>

<h3 class="function"><a name="thread-4">thread/4</a></h3>
<div class="spec">
<p><tt>thread(Module::module(), Function::<a href="#type-func">func()</a>, Args::<a href="#type-args">args()</a>, Store::<a href="#type-store">store()</a>) -&gt; ok</tt><br></p>
</div><p><p>Spawn a function.</p>
 
       Spawn a process executing <code>Module:Function(Args)</code>.
 </p>

<h3 class="function"><a name="union-4">union/4</a></h3>
<div class="spec">
<p><tt>union(Left::<a href="#type-id">id()</a>, Right::<a href="#type-id">id()</a>, Union::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Compute the union of two sets.</p>
 
       Computes the union of two sets and bind the result
       to a third.
 </p>

<h3 class="function"><a name="union-7">union/7</a></h3>
<div class="spec">
<p><tt>union(Left::<a href="#type-id">id()</a>, Right::<a href="#type-id">id()</a>, AccId::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>, BindFun::function(), ReadLeftFun::function(), ReadRightFun::function()) -&gt; {ok, pid()}</tt><br></p>
</div><p><p>Compute the union of two sets.</p>
 
       <p>Computes the union of two sets and bind the result       
to a third.</p>
 
       Similar to <a href="#union-4"><code>union/4</code></a>, however, provides an override
       function for the <code>BindFun</code>, which is responsible for binding the
       result, for instance, when it's located in another table.
 </p>

<h3 class="function"><a name="update-4">update/4</a></h3>
<div class="spec">
<p><tt>update(Id::<a href="#type-id">id()</a>, Operation::<a href="#type-operation">operation()</a>, Actor::<a href="#type-actor">actor()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div><p><p>Update a dataflow variable given an operation.</p>
 
       <p>Similar to <a href="#update-5"><code>update/5</code></a>.</p>
 
       Read the given <code>Id</code> and update it given the provided
       <code>Operation</code>, which should be valid for the type of CRDT stored
       at the given <code>Id</code>.
 </p>

<h3 class="function"><a name="update-5">update/5</a></h3>
<div class="spec">
<p><tt>update(Id::<a href="#type-id">id()</a>, Operation::<a href="#type-operation">operation()</a>, Actor::<a href="#type-actor">actor()</a>, MetadataFun::function(), Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-var">var()</a>}</tt><br></p>
</div>

<h3 class="function"><a name="wait_needed-2">wait_needed/2</a></h3>
<div class="spec">
<p><tt>wait_needed(Id::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-threshold">threshold()</a>}</tt><br></p>
</div><p><p>Pause execution until value requested with given threshold.</p>
 
       Pause execution of calling thread until a read operation is
       issued for the given <code>Id</code>.  Used to introduce laziness into a
       computation.
 </p>

<h3 class="function"><a name="wait_needed-3">wait_needed/3</a></h3>
<div class="spec">
<p><tt>wait_needed(Id::<a href="#type-id">id()</a>, Threshold::<a href="#type-threshold">threshold()</a>, Store::<a href="#type-store">store()</a>) -&gt; {ok, <a href="#type-threshold">threshold()</a>}</tt><br></p>
</div><p><p>Pause execution until value requested with given threshold.</p>
 
       <p>Pause execution of calling thread until a read operation is
       issued for the given <code>Id</code>.  Used to introduce laziness into a       
computation.</p>
 
       This operation blocks until <code>Threshold</code> has been requested.
 </p>

<h3 class="function"><a name="wait_needed-6">wait_needed/6</a></h3>
<div class="spec">
<p><tt>wait_needed(Id::<a href="#type-id">id()</a>, Threshold::<a href="#type-threshold">threshold()</a>, Store::<a href="#type-store">store()</a>, Self::pid(), ReplyFun::function(), BlockingFun::function()) -&gt; {ok, <a href="#type-threshold">threshold()</a>}</tt><br></p>
</div><p><p>Callback wait_needed function for lasp_vnode, where we       
change the reply and blocking replies.</p>
 
       <p>Similar to <a href="#wait_needed-2"><code>wait_needed/2</code></a>.</p>
 
       <p><code>BlockingFun</code> is used to override the handling of waiting for a       
read operation to trigger on something that is waiting (lazy).</p>
 
       <p><code>ReplyFun</code> is used to override the function which is used to       
notify waiting processes, for instance, if they are running on       
another node.</p>
 
       This operation blocks until <code>Threshold</code> has been requested.
 </p>

<h3 class="function"><a name="write-4">write/4</a></h3>
<div class="spec">
<p><tt>write(Type::<a href="#type-type">type()</a>, Value::<a href="#type-value">value()</a>, Key::<a href="#type-id">id()</a>, Store::<a href="#type-store">store()</a>) -&gt; ok</tt><br></p>
</div><p><p>Send responses to waiting threads, via messages.</p>
 
       <p>Perform the following operations:</p>
 
       * Reply to all waiting threads via message.
       * Perform binding of any variables which are partially bound.
       * Mark variable as bound.
       * Check thresholds and send notifications, if required.
 </p>
<hr>

<div class="navbar"><a name="#navbar_bottom"></a><table width="100%" border="0" cellspacing="0" cellpadding="2" summary="navigation bar"><tr><td><a href="overview-summary.html" target="overviewFrame">Overview</a></td><td><a href="http://www.erlang.org/"><img src="erlang.png" align="right" border="0" alt="erlang logo"></a></td></tr></table></div>
<p><i>Generated by EDoc, Aug 7 2015, 16:08:43.</i></p>
</body>
</html>
